#pragma config(Sensor, in1,    gyroSensor,     sensorGyro)
#pragma config(Sensor, dgtl12, PotatoChip,     sensorDigitalIn)
#pragma config(Motor,  port2,           FrontLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FrontRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BackLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BackRightDrive, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int autonomousProgram = 1;

void stopDriveMotors() {
	motor[FrontRightDrive] = 0;
	motor[FrontLeftDrive] = 0;
	motor[BackRightDrive] = 0;
	motor[BackLeftDrive] = 0;
	wait10Msec(0);
}

void driveAllMotors(int frontLeft, int frontRight, int backRight, int backLeft) {
	motor[FrontRightDrive] = frontRight;
	motor[FrontLeftDrive] = frontLeft;
	motor[BackRightDrive] = backRight;
	motor[BackLeftDrive] = backLeft;
}

void driveAllMotors(int allFour) {
	driveAllMotors(allFour, allFour, allFour, allFour);
}

void driveAllMotors(int left, int right) {
	driveAllMotors(left, right, right, left);
}

void liftMotor(int lift) {
	motor[LeftLift] = lift;
	motor[RightLift] = lift;
}

void liftMotorAndWait(int lift, int timespan) {
	liftMotor(lift);
	wait10Msec(timespan);
}

void driveStraightDistance(int tenthsOfIn, int masterPower)
{
  //int tickGoal = (42 * tenthsOfIn) / 10;

  ////This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  //int totalTicks = 0;

  ////Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  ////-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  ////veering off course at the start of the function.
  //int slavePower = masterPower - 5;

  //int error = 0;

  //int kp = 5;

  //SensorValue[leftEncoder] = 0;
  //SensorValue[rightEncoder] = 0;

  ////Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  //while(abs(totalTicks) < tickGoal)
  //{
  //  //Proportional algorithm to keep the robot going straight.
  //  motor[leftServo] = masterPower;
  //  motor[rightServo] = slavePower;

  //  error = SensorValue[leftEncoder] - SensorValue[rightEncoder];

  //  slavePower += error / kp;

  //  SensorValue[leftEncoder] = 0;
  //  SensorValue[rightEncoder] = 0;

  //  wait1Msec(100);

  //  //Add this iteration's encoder values to totalTicks.
  //  totalTicks+= SensorValue[leftEncoder];
  //}
  //motor[leftServo] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  //motor[rightServo] = 0;
}


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton() {
}

void autoOne() {
	char fieldSide;

	if (SensorValue[PotatoChip] == 1) //this means the "Potato Chip" is IN and on the left side
		fieldSide = 'L';
	else //this means the "Potato Chip" is OUT and on the right side
		fieldSide = 'R';

	// drive forward put goal lift out
	driveAllMotors(127);
	liftMotor(127);
	wait10Msec(80); //go forward and lift down
	liftMotorAndWait(0, 0);
	stopDriveMotors();

	// drive forward toward goal
	driveAllMotors(127, 0, 127, 127);
	wait10Msec(150); //this is to prevent programming issues
	stopDriveMotors();

	// bring goal lift in
	liftMotorAndWait(-127, 125);
	//wait10Msec(125); //bring lift up with mobile goal
	liftMotorAndWait(0, 0);	//stop lifting mobile goal

	// back up on an arch
	if (fieldSide == 'L')
	{
		// CHIP OUT - left side of field
		driveAllMotors(-127, -110, -110, -127);
		wait10Msec(310);
		stopDriveMotors();

		motor[FrontLeftDrive] = 127;
		motor[BackLeftDrive] = 127;
		wait10Msec(115);
	}
	else {
		// todo - test this
		// CHIP IN - right side of field
		driveAllMotors(-127, -50, -50, -127);
		wait10Msec(375);
		stopDriveMotors();

		motor[FrontRightDrive] = 100;
		motor[BackRightDrive] = 100;
		wait10Msec(115);
	}
  // driving forward and putting out goal lift
	stopDriveMotors();
	driveAllMotors(127);
	liftMotorAndWait(127, 150);

	// stopping
	liftMotorAndWait(0, 0);

	//bringing the lift in
	liftMotorAndWait(-127, 55);
	liftMotorAndWait(0, 0);

	//backing up from scoring zone
	driveAllMotors(-127);
	wait10Msec(75);
	stopDriveMotors();
}

void autoTwo() {

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous() {
	if (autonomousProgram == 1) {
		autoOne();
	} else {
		autoTwo();
	}
}

/*--------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol() {
	// User control code here, inside the loop
	int liftSpeed = 120;

	while (true) {

		motor[FrontRightDrive] = vexRT[Ch2];
		motor[BackRightDrive] = vexRT[Ch2];
		motor[FrontLeftDrive] = vexRT[Ch3];
		motor[BackLeftDrive] = vexRT[Ch3];

		if (vexRT[Btn6U] == 1) {
			motor[LeftLift] = liftSpeed * -1;
			motor[RightLift] = liftSpeed * -1;
			} else if (vexRT[Btn6D] == 1) {
			motor[LeftLift] = liftSpeed;
			motor[RightLift] = liftSpeed;
			} else {
			motor[LeftLift] = 0;
			motor[RightLift] = 0;
		}

		/*if((vexRT[Btn6UXmtr2] == 1) || ((nVexRCReceiveState & vrXmit2) == false && vexRT[Btn6U] == 1))
		{
		motor[scissorlift] = liftSpeed * -1;
		}
		else if((vexRT[Btn6DXmtr2] == 1) || ((nVexRCReceiveState & vrXmit2) == false && vexRT[Btn6D] == 1))
		{
		motor[scissor lift] = liftSpeed * 1;
		}
		else
		{
		motor[scissor lift] = 0;
		}
		*/

		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		// Remove this function call once you have "real" code.
		// UserControlCodePlaceholderForTesting();
	}
}
